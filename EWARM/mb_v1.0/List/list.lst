###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  06:15:57 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Middlewares\Thi #
#                    rd_Party\FreeRTOS\Source\list.c                          #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Middlewares\Th #
#                    ird_Party\FreeRTOS\Source\list.c" -D USE_FULL_LL_DRIVER  #
#                    -D USE_HAL_DRIVER -D STM32F103xB -lC                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    List\" -o "D:\projects\задания от                        #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/Obj\" --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\list.lst                                             #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\list.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Middlewares\Third_Party\FreeRTOS\Source\list.c
      1          /*
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          
     71          #include <stdlib.h>
     72          #include "FreeRTOS.h"

  /**
    ^
"D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_adc.h",1  Warning[Pa050]: 
          non-native end of line sequence detected (this diagnostic is only
          issued once)
     73          #include "list.h"
     74          
     75          /*-----------------------------------------------------------
     76           * PUBLIC LIST API documented in list.h
     77           *----------------------------------------------------------*/
     78          

   \                                 In section .text, align 2, keep-with-next
     79          void vListInitialise( List_t * const pxList )
     80          {
     81          	/* The list structure contains a list item which is used to mark the
     82          	end of the list.  To initialise the list the list end is inserted
     83          	as the only list entry. */
     84          	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \                     vListInitialise:
   \   00000000   0xF110 0x0108      ADDS     R1,R0,#+8
   \   00000004   0x6041             STR      R1,[R0, #+4]
     85          
     86          	/* The list end value is the highest possible value in the list to
     87          	ensure it remains at the end of the list. */
     88          	pxList->xListEnd.xItemValue = portMAX_DELAY;
   \   00000006   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000A   0x6081             STR      R1,[R0, #+8]
     89          
     90          	/* The list end next and previous pointers point to itself so we know
     91          	when the list is empty. */
     92          	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \   0000000C   0xF110 0x0108      ADDS     R1,R0,#+8
   \   00000010   0x60C1             STR      R1,[R0, #+12]
     93          	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \   00000012   0xF110 0x0108      ADDS     R1,R0,#+8
   \   00000016   0x6101             STR      R1,[R0, #+16]
     94          
     95          	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6001             STR      R1,[R0, #+0]
     96          
     97          	/* Write known values into the list if
     98          	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
     99          	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    100          	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
    101          }
   \   0000001C   0x4770             BX       LR               ;; return
    102          /*-----------------------------------------------------------*/
    103          

   \                                 In section .text, align 2, keep-with-next
    104          void vListInitialiseItem( ListItem_t * const pxItem )
    105          {
    106          	/* Make sure the list item is not recorded as being on a list. */
    107          	pxItem->pvContainer = NULL;
   \                     vListInitialiseItem:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6101             STR      R1,[R0, #+16]
    108          
    109          	/* Write known values into the list item if
    110          	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    111          	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    112          	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    113          }
   \   00000004   0x4770             BX       LR               ;; return
    114          /*-----------------------------------------------------------*/
    115          

   \                                 In section .text, align 2, keep-with-next
    116          void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
    117          {
    118          ListItem_t * const pxIndex = pxList->pxIndex;
   \                     vListInsertEnd:
   \   00000000   0x6842             LDR      R2,[R0, #+4]
    119          
    120          	/* Only effective when configASSERT() is also defined, these tests may catch
    121          	the list data structures being overwritten in memory.  They will not catch
    122          	data errors caused by incorrect configuration or use of FreeRTOS. */
    123          	listTEST_LIST_INTEGRITY( pxList );
    124          	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
    125          
    126          	/* Insert a new list item into pxList, but rather than sort the list,
    127          	makes the new list item the last item to be removed by a call to
    128          	listGET_OWNER_OF_NEXT_ENTRY(). */
    129          	pxNewListItem->pxNext = pxIndex;
   \   00000002   0x604A             STR      R2,[R1, #+4]
    130          	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   \   00000004   0x6893             LDR      R3,[R2, #+8]
   \   00000006   0x608B             STR      R3,[R1, #+8]
    131          
    132          	/* Only used during decision coverage testing. */
    133          	mtCOVERAGE_TEST_DELAY();
    134          
    135          	pxIndex->pxPrevious->pxNext = pxNewListItem;
   \   00000008   0x6893             LDR      R3,[R2, #+8]
   \   0000000A   0x6059             STR      R1,[R3, #+4]
    136          	pxIndex->pxPrevious = pxNewListItem;
   \   0000000C   0x6091             STR      R1,[R2, #+8]
    137          
    138          	/* Remember which list the item is in. */
    139          	pxNewListItem->pvContainer = ( void * ) pxList;
   \   0000000E   0x6108             STR      R0,[R1, #+16]
    140          
    141          	( pxList->uxNumberOfItems )++;
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    142          }
   \   00000016   0x4770             BX       LR               ;; return
    143          /*-----------------------------------------------------------*/
    144          

   \                                 In section .text, align 2, keep-with-next
    145          void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
    146          {
   \                     vListInsert:
   \   00000000   0xB410             PUSH     {R4}
    147          ListItem_t *pxIterator;
    148          const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   \   00000002   0x680B             LDR      R3,[R1, #+0]
    149          
    150          	/* Only effective when configASSERT() is also defined, these tests may catch
    151          	the list data structures being overwritten in memory.  They will not catch
    152          	data errors caused by incorrect configuration or use of FreeRTOS. */
    153          	listTEST_LIST_INTEGRITY( pxList );
    154          	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
    155          
    156          	/* Insert the new list item into the list, sorted in xItemValue order.
    157          
    158          	If the list already contains a list item with the same item value then the
    159          	new list item should be placed after it.  This ensures that TCB's which are
    160          	stored in ready lists (all of which have the same xItemValue value) get a
    161          	share of the CPU.  However, if the xItemValue is the same as the back marker
    162          	the iteration loop below will not end.  Therefore the value is checked
    163          	first, and the algorithm slightly modified if necessary. */
    164          	if( xValueOfInsertion == portMAX_DELAY )
   \   00000004   0xF113 0x0F01      CMN      R3,#+1
   \   00000008   0xD101             BNE.N    ??vListInsert_0
    165          	{
    166          		pxIterator = pxList->xListEnd.pxPrevious;
   \   0000000A   0x6902             LDR      R2,[R0, #+16]
   \   0000000C   0xE007             B.N      ??vListInsert_1
    167          	}
    168          	else
    169          	{
    170          		/* *** NOTE ***********************************************************
    171          		If you find your application is crashing here then likely causes are
    172          		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
    173          		more tips, and ensure configASSERT() is defined!
    174          		http://www.freertos.org/a00110.html#configASSERT
    175          
    176          			1) Stack overflow -
    177          			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
    178          			2) Incorrect interrupt priority assignment, especially on Cortex-M
    179          			   parts where numerically high priority values denote low actual
    180          			   interrupt priorities, which can seem counter intuitive.  See
    181          			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
    182          			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
    183          			   http://www.freertos.org/a00110.html
    184          			3) Calling an API function from within a critical section or when
    185          			   the scheduler is suspended, or calling an API function that does
    186          			   not end in "FromISR" from an interrupt.
    187          			4) Using a queue or semaphore before it has been initialised or
    188          			   before the scheduler has been started (are interrupts firing
    189          			   before vTaskStartScheduler() has been called?).
    190          		**********************************************************************/
    191          
    192          		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \                     ??vListInsert_0:
   \   0000000E   0xF110 0x0208      ADDS     R2,R0,#+8
   \   00000012   0xE000             B.N      ??vListInsert_2
   \                     ??vListInsert_3:
   \   00000014   0x6852             LDR      R2,[R2, #+4]
   \                     ??vListInsert_2:
   \   00000016   0x6854             LDR      R4,[R2, #+4]
   \   00000018   0x6824             LDR      R4,[R4, #+0]
   \   0000001A   0x42A3             CMP      R3,R4
   \   0000001C   0xD2FA             BCS.N    ??vListInsert_3
    193          		{
    194          			/* There is nothing to do here, just iterating to the wanted
    195          			insertion position. */
    196          		}
    197          	}
    198          
    199          	pxNewListItem->pxNext = pxIterator->pxNext;
   \                     ??vListInsert_1:
   \   0000001E   0x6853             LDR      R3,[R2, #+4]
   \   00000020   0x604B             STR      R3,[R1, #+4]
    200          	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   \   00000022   0x684B             LDR      R3,[R1, #+4]
   \   00000024   0x6099             STR      R1,[R3, #+8]
    201          	pxNewListItem->pxPrevious = pxIterator;
   \   00000026   0x608A             STR      R2,[R1, #+8]
    202          	pxIterator->pxNext = pxNewListItem;
   \   00000028   0x6051             STR      R1,[R2, #+4]
    203          
    204          	/* Remember which list the item is in.  This allows fast removal of the
    205          	item later. */
    206          	pxNewListItem->pvContainer = ( void * ) pxList;
   \   0000002A   0x6108             STR      R0,[R1, #+16]
    207          
    208          	( pxList->uxNumberOfItems )++;
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x6001             STR      R1,[R0, #+0]
    209          }
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
    210          /*-----------------------------------------------------------*/
    211          

   \                                 In section .text, align 2, keep-with-next
    212          UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
    213          {
    214          /* The list item knows which list it is in.  Obtain the list from the list
    215          item. */
    216          List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   \                     uxListRemove:
   \   00000000   0x6901             LDR      R1,[R0, #+16]
    217          
    218          	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   \   00000004   0x6883             LDR      R3,[R0, #+8]
   \   00000006   0x6093             STR      R3,[R2, #+8]
    219          	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   \   00000008   0x6882             LDR      R2,[R0, #+8]
   \   0000000A   0x6843             LDR      R3,[R0, #+4]
   \   0000000C   0x6053             STR      R3,[R2, #+4]
    220          
    221          	/* Only used during decision coverage testing. */
    222          	mtCOVERAGE_TEST_DELAY();
    223          
    224          	/* Make sure the index is left pointing to a valid item. */
    225          	if( pxList->pxIndex == pxItemToRemove )
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0x4282             CMP      R2,R0
   \   00000012   0xD101             BNE.N    ??uxListRemove_0
    226          	{
    227          		pxList->pxIndex = pxItemToRemove->pxPrevious;
   \   00000014   0x6882             LDR      R2,[R0, #+8]
   \   00000016   0x604A             STR      R2,[R1, #+4]
    228          	}
    229          	else
    230          	{
    231          		mtCOVERAGE_TEST_MARKER();
    232          	}
    233          
    234          	pxItemToRemove->pvContainer = NULL;
   \                     ??uxListRemove_0:
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x6102             STR      R2,[R0, #+16]
    235          	( pxList->uxNumberOfItems )--;
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   \   00000020   0x6008             STR      R0,[R1, #+0]
    236          
    237          	return pxList->uxNumberOfItems;
   \   00000022   0x6808             LDR      R0,[R1, #+0]
   \   00000024   0x4770             BX       LR               ;; return
    238          }
    239          /*-----------------------------------------------------------*/
    240          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  uxListRemove
        0  vListInitialise
        0  vListInitialiseItem
        4  vListInsert
        0  vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      38  uxListRemove
      30  vListInitialise
       6  vListInitialiseItem
      54  vListInsert
      24  vListInsertEnd

 
 152 bytes in section .text
 
 152 bytes of CODE memory

Errors: none
Warnings: 1
